# 第十四课 - 两个函数共用内存

#### 例1：上一节课最后一例

```c
int fn() {
    int array[4];
    int i;
    for (i=0; i<=4; i++) {
        array[i] -= 4;
    }
    return 0;
}
```

函数栈如下图所示：

（图1）

由于 c 语言编译过程没有越界检查，且 array\[3\] + 4 地址处存着执行完 fn 函数之后应该执行的命令地址，即图中虚线箭头指向的地址，但由于 array\[4\] -= 4 的操作使得 saved pc 自减 4，再次指向 fn 函数，因此 fn 将被重复执行，陷入死循环。需要注意的是，本例中谈论的编译过程并不使用于所有情况，不同的编译器会采取不同的参数、返回地址存放方式，本例只是展示可能的一种情况。

