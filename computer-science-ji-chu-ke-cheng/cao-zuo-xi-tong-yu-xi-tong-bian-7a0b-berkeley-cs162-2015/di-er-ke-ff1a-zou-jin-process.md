# 第二课：走近 Process

本节主要涉及到四个基本 OS 概念：

* 线程 \(Thread\)：单个独立的执行上下文 \(Single unique execution context\)，它其中包含如 Program Counter \(PC\)、Registers、Execution Flags、Stack 等信息。
* 地址空间与地址转换 \(Address Space & Translation\)：所有运行中的程序都认为自己拥有完整、连续的内存地址空间，而 OS 在背后完成虚拟地址空间到物理地址空间的转换。
* 进程 \(Process\)：程序运行起来就成为进程，每个进程都认为自己有一块完整、连续的内存地址空间，同时每个进程可能拥有一个或多个线程在控制其运行过程。
* 双模操作及保护 \(Dual Mode operation/Protection\)：
  * OS 为用户进程提供了虚拟的硬件服务，如网络、硬盘、输入输出等，但用户进程不能直接接触硬件本身，而只能通过 OS 获取。这就需要双模操作，即 user mode 和 kernel mode，来保护整个过程顺利、安全地进行。
  * 不同用户进程运行同样需要隔离保护，OS 可以通过控制地址转换的过程保证不同的进程只能在不同的物理地址空间中寻址。

### 程序的运行过程

（图1）

工程师写完程序源代码后，交由编译器去将源代码编译成可执行机器码。运行程序时，OS 将可执行机器码被载入到内存中，并为其创建 Stack 和 Heap，然后将控制权转交给该进程，为该进程提供各种虚拟服务，同时保护 OS 以及其它用户进程与之互不干扰。

（图2）

进程的运行过程如上图所示，简而言之就是一个 "获取指令 - 执行指令" 的循环：

* 获取 PC 所指的指令
* 解析指令
* 执行指令
* 将结果写出到寄存器或内存
* 更新 PC，让它指向下一条指令
* 回到第一步

### 基本 OS 概念

#### 线程 \(Thread\)

线程是最小的执行单位，它仅包含执行所需上下文信息。当线程中的上下文信息映射在 CPU 中的寄存器上时，则线程处于运行状态。

* 寄存器 PC \(program counter\) 保存线程下一条指令所在地址
* 寄存器 SP \(stack pointer\) 保存线程栈顶的地址
* ...

#### 程序的地址空间 \(Program's Address Space\)

（图3）

如上图所示，每个程序在运行时都拥有自己的内存地址空间，这个空间被划分为 4 个主要区域：

* 代码段 \(Code Segment\)：代码段保存着控制程序执行的可执行机器码，寄存器 PC 就指向这个区域中的某个地址。
* 静态数据 \(Static Data\)：静态数据保留程序所需的全局的静态数据
* 堆 \(Heap\)：堆用于内存空间的动态分配，它由低地址向高地址方向增长
* 栈 \(Stack\)：栈用于存储局部、临时的数据，它由高地址向低地址方向增长

当 OS 中同时存在多个正在运行的程序时，内存中就会存有多个内存寻址空间，如下图所示：

（图4）

每个工程师在构建程序时，无需考虑程序运行时环境中存在的其它程序，每个程序都认为自己：

* 拥有独立的 CPU
* 拥有独立的内存空间

那么 OS 如何为每个运行的程序创造这种假象？以多处理器的假象为例：

假设系统实际上只有一个处理器，OS 如何用一个处理器抽象出多处理器的假象？最简单直观的方法就是**分时**，为每个正在运行的程序轮流分配处理器的使用时间，当一个程序的使用时间到期时，就把它的执行上下文信息储存起来，然后载入队伍中下一个正在运行的程序的执行上下文信息，继续执行，如下图所示：

（图5）

这就是所谓的**并发**。但有收获必有牺牲，并发引入了系统复杂度。所有硬件都为所有程序共享，那么 OS 就需要为所有硬件创造假象，如 CPU、DRAM、I/O 设备等等。提供了假象还远远不够，如果所有运行中的程序都分享所有硬件，这意味着每个运行的程序都有机会获取、修改共享的硬件中的信息，如 DRAM，因此 OS 除了提供每个运行的程序都独占硬件的假像，还需要提供保护机制，让不同的运行程序在不破坏其它运行程序的同时独占硬件。

#### 进程 \(Process\)



