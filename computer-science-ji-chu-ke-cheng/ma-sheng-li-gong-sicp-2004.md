# 第三课 - 替代模型

替代模型实际上是一种思维模型，让我们可以在心里推导一个**表达式**在计算机中的演进过程。理解替代模型可以帮助我们更合理地设计程序，从而使程序向我们所希望的方向演进。

Scheme 的替代模型可以概括如下：

1. 如果是自评价 \(self-evaluating\) 表达式，直接返回其值

2. 如果是名字表达式，使用名字对应的值替代原表达式

3. 如果是 lambda 表达式，创建程序 \(procedure\) 并将其返回

4. 如果是特殊形式表达式，依照特殊规则来评价子表达式 \(sub-expressions\)，如 if, cond 等

5. 如果是复合 \(compound or combination\) 表达式：

   5.1 任意顺序评价子表达式

   5.2 如果第一个子表达式是原始程序，直接应用到子表达式的评价值上

   5.3 如果第一个子表达式是复合程序，则将子表达式的评价值替换复合程序 \(lambda 表达式创造\) 的函数体中的对应变量，然后将整个函数体表达式替换原复合表达式，将其作为新的表达式重复评价过程

举个简单例子： \(注释对应替代规则\)

```scheme
(define square (lambda (x) (* x x)))

; 1. (square 4) 				// 5.1
;   1. 4 -> 4 				        // 1
;   2. Square -> #procedure	                // 2
; 2. (* 4 4) 					// 5.3
;   1. 4 -> 4					// 1
;   2. 4 -> 4					// 1
; 3. 16						// 5.2
```

举个复杂的例子：\(注释对应替代规则\)

```scheme
(define square 
  (lambda (x) (* x x)))
(define average
  (lambda (x y) (/ (+ x y) 2)))
  
; 1. (average 5 (square 3)) 	                // 5.1
;   1. average -> #procedure 	                // 2
;   2. 5 -> 5					// 1
;   3. (square 3)				// 5.1
;   	1. square -> #procedure               // 2
;   	2. 3 -> 3 				// 1
;   	3. (* 3 3) 				// 5.3
;   	4. 9 					// 5.2
; 2. (/ (+ 5 9) 2) 			        // 5.3，5.1
;   1. (+ 5 9) -> 14			        // 5.1
; 	1. 5 -> 5				// 1
; 	2. 9 -> 9				// 1
;   2. 2 -> 2 				        // 1
; 3. 7 						// 5.2
```

递归例子：

```scheme
(define fact
  (lambda (n)
  	(if (= n 1)
  	  1
  	  (* n (fact (- n 1))))))

; 1. (fact 3) 									// 2, 5.3
; 2. (if (= 3 1) 1 (* 3 (fact (- 3 1))))			                // 4 (if)
; 3. (if #f 1 (* 3 (fact (- 3 1)))) 				                // 4 (if)
; 4. (* 3 (fact (- 3 1))) 						        // 5.2
; 5. (* 3 (fact 2)) 								// 2, 5.3
; 6. (* 3 (if (= 2 1) 1 (* 2 (fact (- 2 1))))) 	                        // 4 (if)
; 7. (* 3 (if #f 1 (* 2 (fact (- 2 1))))) 		                        // 4 (if)
; 8. (* 3 (* 2 (fact (- 2 1)))) 					        // 5.2
; 9. (* 3 (* 2 (fact (1)))) 						        // 2, 5.3
; 10.(* 3 (* 2 (if (= 1 1) 1 (* 1 (fact (- 1 1))))))                         // 4(if)
; 11.(* 3 (* 2 (if #t 1 (* 1 (fact (- 1 1))))))                             // 4(if)
; 12.(* 3 (* 2 1)) 								// 5.2
; 13.(* 3 2) 								        // 5.2
; 14.6
```



